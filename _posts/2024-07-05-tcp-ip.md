---
title: 'TCP/IP'
excerpt_separator: '<!--more-->'
categories:
  - CS
tags:
  -
header:
  teaser: ./assets/image/45.png
toc: true
toc_sticky: true
toc_label: 'CONTENTS'
---

<br>
<!-- https://kr.freepik.com/
https://ye-yo.github.io/thumbnail-maker/ -->
<!--  source ~/.bash_profile   -->
<!-- bundle exec jekyll serve -->

## REST의 제약조건

<br>
### **계층형 시스템 (Layered System)**
  
- 클라이언트와 서버 사이에 여러 중간 계층을 두어 시스템의 유연성, 확장성, 보안성을 향상시켜야한다.  
      
    → 클라이언트는 최종 목적지인 서버에 요청을 보내기만 하면되며, 중간 계층들은 각자의 역할을 수행하여 시스템의 효율성을 높일 수 있다.  
      
  
REST의 제약조건 중에는 계층형 시스템이 있었는데  
여기서 말하는 시스템의 효율성을 높여줄 수 있는 중간 계층들은 무엇일까?  
  
<br><br><br>
## **OSI 7** 계층 & **TCP/IP** 계층
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/592143a9-0b3e-4084-94c5-7a821982ad06' alt=''>
  
중간 계층이라 할 수 있는 OSI 7 계층 과 TCP/IP 계층이 있는데  
두 계층 모두 네트워크 통신에 필요한 프로토콜들을 계층화하여 체계적으로 구성한 모델로  
인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 프로토콜의 집합이라고 할 수 있다.  
  
<br>
### OSI (Open Systems Interconnection Reference Model) 7 계층
  
> 국제표준화기구(ISO)에서 개발한 모델로,  
이 모델은 서로 다른 컴퓨터 기기간의 네트워크를 형성할 수 있도록 규정한 네트워크 모델 표준안 이다.  
>
  
  
{:.notice--primary}
💡 **`프로토콜들을 계층화한 이유는?`**<br><br>
1980년대 네트워크 통신망이 확산되면서 다양한 통신망이 혼재된 상태였다.  
이에 따라 네트워크 유형에 관계없이 상호 통신이 가능한 지침이 필요했고,  
이러한 필요성이 대두됨으로써 OSI 7 계층이라는 새로운 네트워크 모델을 발표헀다.  
용이성과 유지관리를 위해 각 계층을 독립적으로 다룰 수 있도록 7가지의 계층으로 나누어,  
특정한 계층에 이상이 생기면 다른 계층의 장비 및 소프트웨어를 건들이지 않고도 이상이 생긴 단계만 고칠 수 있었던 것 이다.  
  
  
<br>
### TCP/IP (**Transmission Control Protocol/Internet Protocol**) 계층
  
> OSI 7계층은 각 계층의 기능과 역할에 대한 이론적인 설명을 잘 제공되어있지만   
실무적으로 이용하기에 OSI 7 계층 모델의 복잡성 때문에  
이를 단순화하면서도 인터넷에서 사용되는 실질적인 프로토콜들로 구성되어있는 것이 TCP/IP 4계층이다.  
>
  
  
<br>
### OSI 7 계층 vs TCP/IP 계층
  
- **계층 구조**  
      
    TCP/IP의 응용 계층은 OSI의 상위 3계층(응용, 표현, 세션)을 포함하며,   
    네트워크 인터페이스 계층은 OSI의 하위 2계층(물리, 데이터 링크)을 포함하는 4계층이다.  
      
- **사용 목적**  
      
    TCP/IP는 인터넷의 표준 프로토콜로 개발되었으며, 실질적인 통신을 위해 사용된다.  
    OSI 7계층은 이론적인 참조 모델로 개발되어 실제 통신에는 사용되지 않지만  
    네트워크 기술 및 프로토콜의 표준화를 위해 사용된다.  
      
- **상관 관계**  
      
    두 모델의 사용 목적은 다르지만   
    네트워크 엔지니어, 개발자 및 관리자는 두 모델을 함께 활용하여 네트워크 문제를 해결하고  
    최적의 네트워크 구성 및 설계를 수행할 수 있다.  
    즉, TCP/IP와 OSI 모델은 서로 보완적으로 사용될 수 있으며,   
    네트워크 설계 및 문제 해결에 있어 유용한 도구가 된다.  
      
  
그럼 이 중간계층의 역할은 무엇일까?  
  
<br><br><br>
## 브라우저에 URL을 입력했을 때의 흐름
  
  
면접에서 단골질문으로 나오는 질문 중 하나로,  
이 질문에 대한 답변에 대해 더 자세히 알아보면 이 중간 계층의 역할이 무엇인지 알 수 있다.  
큰 틀만 보자면 아래와 같이 말할 수 있다.  
  
{:.notice--primary}
💡 **`“브라우저에 URL을 입력했을 때의 흐름에 대해서 말씀해주시겠어요?”`**<br><br>
웹 브라우저에 URL을 입력하면, 먼저 DNS 조회를 통해 도메인 이름을 IP 주소로 변환합니다.   
이후 브라우저는 해당 서버에 TCP 연결을 설정하고, 이를 통해 HTTP 요청을 보냅니다.   
그럼 서버는 요청을 처리하고, 웹 페이지 콘텐츠를 담은 HTTP 응답을 반환하게 되고   
브라우저는 받은 데이터를 렌더링하여 사용자에게 보여주고, 마지막으로 TCP 연결을 종료합니다.  
  
  
더 자세한 흐름을 알아보기 위해서,  
각 계층 별로 HTTP, TCP, IP, Ethernet 프로토콜을 사용한다고 가정해보자.  
  
{:.notice--primary}
  
  
{:.notice--primary}
💡 **`캡슐화(Encapsulation) & 역캡슐화(Decapsulation)`**<br><br>
<br>
◾ **캡슐화 (Encapsulation)**: 통신 프로토콜의 특성을 포함한 정보를 헤더(Header)에 추가하여 하위 계층에 전송하는 과정이다.   
사용자가 전송하고자 하는 데이터는 각 프로토콜의 정보를 헤더에 포함시켜 전달되며,   
최종적으로 물리 계층에서 이 데이터는 이진(binary) 형태로 변환되어 전송된다.  
◾ **역캡슐화 (Decapsulation)**: 통신 상대측에서 헤더를 역순으로 제거하면서 원래의 데이터를 얻는 과정이다.   
상대측은 헤더를 하나씩 제거하며 상위 계층으로 데이터를 전달하고,   
최종적으로 원본 데이터를 수신하게 된다.  
  
  
{:.notice--primary}
💡 **`프로토콜 헤더 분석: TCP, IP, Ethernet`**<br><br>
◾ **TCP 헤더**  
<br>
    출발지 포트번호 (Source Port): 클라이언트가 사용하는 컴퓨터에서 만든 소켓의 포트 번호이다.  
    목적지 포트번호 (Destination Port): 서버가 수신할 포트 번호로, 일반적으로 HTTP의 경우 80, HTTPS의 경우 443이다.  
<br>
◾ **IP 헤더**  
<br>
    출발지 IP 주소 (Source Address): 패킷을 전송하는 장치의 IP 주소이다.  
    목적지 IP 주소 (Destination Address): 패킷이 도착할 장치의 IP 주소로, DNS 쿼리를 통해 확인할 수 있다.  
<br>
◾ **Ethernet 헤더**  
<br>
    출발지 MAC 주소 (Source Address): 패킷을 전송하는 장치의 MAC 주소이다.  
    목적지 MAC 주소 (Destination Address): 패킷이 도착할 장치의 MAC 주소로, 물리적으로 연결된 네트워크 장치(예: 라우터, 스위치)의 MAC 주소를 의미한다.  
  
  
TCP/IP 계층은 인터넷 통신에서 가장 중요한 역할을 하는 TCP와 IP 프로토콜의 이름을 따서 명명되었는데  
그렇다면 TCP와 IP 프로토콜에 대해서 자세히 알아보자.  
  
<br><br><br>
## TCP (Transmission Control Protocol) 란?
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/7c25a379-3395-4ccc-8d7b-e2bc41ebed8a' alt=''>
  
전송 제어 프로토콜이라는 의미로  
연결지향적이며 신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜이다.  
자세하게 말하면,   
장치들 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스라고 할 수 있다.  
  
- TCP의 통신은 connection setup / data transfer / connection termination 세 단계로 나뉜다.  
- **전이중 방식**: 전송이 양방향으로 동시에 일어날 수 있다.  
- **데이터의 순차 전송을 보장**: 데이터의 전달을 보증하고 보낸 순서대로 받게 한다.  
- **handshake**: 데이터를 상대방에게 확실하게 보내기 위해서 handshake 방식을 사용하는데   
TCP의 접속 시에는 3-way handshake, TCP의 접속 해제 시에는 4-way handshake 라는 방식을 사용한다.  
- **흐름 제어**: 송신자와 수신자 간의 데이터 전송 속도를 조절하여 수신자가 처리할 수 있는 양을 초과하지 않도록(버퍼 오퍼블로우 방지)하는 메커니즘이다.  
- **혼잡 제어**: 패킷 수를 조절하여 네트워크가 혼잡해지지 않도록 하고 패킷 손실을 줄인다.  
- **오류 감지**: 수신자는 수신한 데이터의 무결성을 확인하고, 오류가 발생한 경우 재전송을 요청한다.  
  
<br>
### 3-way handshake (connection setup)
  
{:.notice--primary}
💡 **`TCP 세그먼트`**<br><br>
TCP는 데이터의 신뢰성을 보장하기 위해 데이터를 세그먼트 단위로 나누는데  
이 세그먼트 안에는 아래와 같은 구성요소를 가지고있다.  
<br>
◾ **출발지 포트 (Source Port)**: 데이터를 보내는 애플리케이션의 포트 번호로, 송신 측에서 사용된다.  
◾ **목적지 포트 (Destination Port)**: 데이터를 받는 애플리케이션의 포트 번호로, 수신 측에서 사용된다..  
◾ **순서 번호 (Sequence Number)**: 전송된 데이터의 순서를 나타내며, 수신 측에서 데이터의 올바른 순서로 재조립하는 데 사용된다.  
◾ **확인 응답 번호 (Acknowledgment Number)**: 수신자가 성공적으로 받은 세그먼트의 순서 번호로, 데이터의 손실 여부를 확인하고 재전송 요청을 할 수 있게 한다..  
◾ **플래그 (Flags)**: TCP 연결 제어에 사용되는 여러 플래그로, 예를 들어 SYN(연결 요청), ACK(응답), FIN(연결 종료) 등이 있다.  
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/772552d3-aab6-44cf-ba05-4073f1a61591' alt=''>
  
1. 클라이언트가 서버에 SYN 비트를 1로 설정하여 패킷을 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 12345 | 80 | x | 0 (확인할 데이터 x) | SYN = 1, ACK = 0 |  
2. 서버는 SYN 을 수신한 후, 연결을 수립할 준비가 되었다는 의미로  
SYN, ACK 비트를 1로 설정하여 패킷을 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 80 | 12345 | y | x + 1 | SYN = 1, ACK = 1 |  
3. 클라이언트는 SYN, ACK 을 수신한 후, 서버가 연결 요청을 수락했음을 알게되고  
클라이언트와 서버 양쪽 모두 연결이 성립되었다는 의미로  
클라이언트가 ACK 비트를 1로 설정하여 패킷을 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 12345 | 80 | x + 1 | y + 1 | SYN = 0, ACK = 1 |  
  
<br>
### data transfer
  
1. 클라이언트가 패킷을 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 12345 | 80 | x + 2 | y + 2 | SYN = 0, ACK = 1 |  
2. 서버는 ACK 를 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 80 | 12345 | y + 1 | x + 3 | SYN = 0, ACK = 1 |  
3. 클라이언트가 ACK를 수신하지 못하면 재전송한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 12345 | 80 | x + 2 | y + 3 | SYN = 0, ACK = 1 |  
  
<br>
### 4-way handshake (connection termination)
  
<img class='img-full' src='https://github.com/user-attachments/assets/e565ac7b-1157-4bc6-9f71-457a6f92228f' alt=''>
  
1. 데이터를 전부 송신한 클라이언트가 연결 종료를 위해 FIN 을 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 12345 | 80 | x + 3 | y + 3 | FIN = 1, ACK = 1 |  
2. 서버가 FIN 을 수진하고 이를 확인하기 위해 ACK 를 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 80 | 12345 | y + 2 | x + 4 | FIN = 0, ACK = 1 |  
3. 서버에서 클라이언트에게 남은 패킷을 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 80 | 12345 | y + 3 | x + 4 | FIN = 0, ACK = 1 |  
4. 서버는 모든 데이터를 송신한 후 연결 종료를 요청하기 위해 FIN 을 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 80 | 12345 | y + 4 | x + 4 | FIN = 1, ACK = 1 |  
5. 클라이언트가 FIN 을 수진하고 이를 확인하기 위해 ACK 를 송신한다.  
      
      
    | **Source Port** | **Destination Port** | **Sequence Number** | **Acknowledgment Number** | **Flag** |  
    | --- | --- | --- | --- | --- |  
    | 12345 | 80 | x + 4 | y + 5 | FIN = 0, ACK = 1 |  
  
{:.notice--primary}
💡 **`Time Wait`**<br><br>
서버가 FIN을 보내는 과정에서  
서버가 FIN을 보내기 전에 보냈던 데이터가 FIN보다 늦게 도착 할 경우 문제가 발생할 수 있는데  
서버로 부터 FIN을 수신했다고 클라이언트가 바로 연결된 소켓을 닫아버리면   
FIN을 보내기 전에 보낸 패킷은 영영 클라이언트가 받을 수 없게 된다.  
그래서 클라이언트는 서버로부터 FIN 요청을 받더라도 일정시간 동안 소켓을 닫지않고  
혹시나 아직 도착하지 않은 잉여 패킷이 없는지 기다리게 되는데  
즉, 4-way handshake 과정이 완료되어도 소켓을 닫지않고 잉여패킷을 기다리는 상태를 Time Wait 이라고 한다.  
  
  
<br><br><br>
## 흐름 제어
  
  
흐름 제어는 송신자와 수신자 간의 데이터 전송 속도를 조절하여 수신자가 데이터를 처리할 수 있는 능력을 초과하지 않도록 하는 메커니즘이다. 이를 통해 데이터 손실을 방지하고, 네트워크의 효율성을 높일 수 있다.  
  
<br>
### Stop and Wait
  
Stop and Wait는 가장 기본적인 흐름 제어 기법으로, 송신자가 데이터를 전송한 후 수신자로부터 확인 응답(ACK)을 받을 때까지 기다리는 방식이다. 이 방식의 특징은 다음과 같다:  
  
- **단순한 프로토콜:** Stop and Wait는 구현이 간단하여 초기 설정이 용이하다. 송신자는 패킷을 전송하고, 수신자는 패킷을 수신한 후 ACK를 송신한다.  
- **효율성 저하:** 송신자는 ACK를 기다리는 동안 아무런 작업을 수행하지 않기 때문에, 네트워크 대역폭을 효율적으로 사용하지 못한다. 특히, RTT(Round Trip Time)가 긴 경우 성능이 크게 저하될 수 있다. 예를 들어, RTT가 100ms인 경우, 송신자는 패킷을 전송한 후 100ms를 기다려야 하므로, 데이터 전송 속도가 느려질 수 있다.  
- **데이터 손실 방지:** 수신자가 데이터를 처리할 수 있는 속도에 맞춰 송신자가 전송하므로, 수신자가 데이터를 잃어버릴 가능성이 줄어든다. 수신자는 수신한 패킷에 대해 ACK를 보내고, 송신자는 ACK를 수신한 후 다음 패킷을 전송한다.  
- **제한된 성능:** Stop and Wait 방식은 대역폭이 큰 네트워크에서는 비효율적이다. 대역폭이 크고 RTT가 긴 경우, 송신자는 대기 시간 동안 대역폭을 활용하지 못하므로, 전체 전송 속도가 저하된다.  
  
<br>
### Sliding Window
  
Sliding Window는 Stop and Wait의 단점을 보완하기 위해 고안된 흐름 제어 기법이다. 이 방식에서는 송신자가 여러 개의 패킷을 전송한 후, 수신자로부터 ACK를 기다리는 동안 다른 패킷을 계속 전송할 수 있다. 주요 특징은 다음과 같다:  
  
- **윈도우 크기:** 송신자는 한 번에 전송할 수 있는 패킷의 수를 정의하는 윈도우 크기를 설정한다. 이 크기는 네트워크의 상태에 따라 조정될 수 있다. 예를 들어, 윈도우 크기가 4인 경우, 송신자는 최대 4개의 패킷을 전송할 수 있다.  
- **효율성 향상:** 여러 패킷을 동시에 전송할 수 있어, 네트워크 대역폭을 보다 효율적으로 사용할 수 있다. 특히, RTT가 긴 경우에도 성능 저하를 최소화할 수 있다. 송신자는 ACK를 기다리는 동안 다른 패킷을 전송하므로, 대기 시간을 줄일 수 있다.  
- **혼잡 감지:** 수신자는 수신 가능한 패킷의 수를 관리하여, 송신자가 과도한 데이터를 전송하지 않도록 한다. 수신자는 수신한 패킷에 대해 ACK를 보내고, 송신자는 ACK를 수신한 후 윈도우 크기에 따라 추가 패킷을 전송한다.  
- **동적 조정:** Sliding Window는 네트워크의 상태에 따라 윈도우 크기를 동적으로 조정할 수 있다. 네트워크가 혼잡해지면 윈도우 크기를 줄이고, 혼잡하지 않으면 윈도우 크기를 늘릴 수 있다.  
  
<br><br><br>
## 혼잡 제어
  
  
혼잡 제어는 네트워크의 혼잡 상태를 감지하고, 이를 완화하기 위한 메커니즘이다. 혼잡이 발생하면 패킷 손실, 지연 증가 등의 문제가 발생할 수 있다.  
  
<br>
### AIMD (Additive Increase Multiplicative Decrease)
  
AIMD는 혼잡 제어의 기본 알고리즘으로, 네트워크의 혼잡 상태에 따라 전송 속도를 조절하는 방식이다. 주요 특징은 다음과 같다:  
  
- **가산 증가:** 네트워크가 혼잡하지 않은 경우, 송신자는 전송 속도를 점진적으로 증가시킨다. 일반적으로, 매 RTT마다 윈도우 크기를 1씩 증가시킨다. 예를 들어, 윈도우 크기가 5인 경우, 다음 RTT에는 6으로 증가한다.  
- **곱셈 감소:** 혼잡이 감지되면, 송신자는 전송 속도를 급격히 줄인다. 일반적으로, 윈도우 크기를 절반으로 줄이는 방식으로 구현된다. 예를 들어, 윈도우 크기가 6에서 혼잡이 감지되면 3으로 줄어든다.  
- **균형 유지:** AIMD는 네트워크의 혼잡 상태를 감지하고, 이를 기반으로 전송 속도를 조절하여 안정적인 데이터 전송을 유지한다. 이 방식은 네트워크의 혼잡을 완화하고, 데이터 전송의 신뢰성을 높인다.  
- **혼잡 회피:** AIMD는 혼잡 상태를 감지하고, 이를 기반으로 전송 속도를 조절하여 혼잡을 회피한다. 이로 인해 네트워크의 성능이 향상된다.  
  
<br>
### Slow Start
  
Slow Start는 TCP의 혼잡 제어 알고리즘 중 하나로, 연결이 시작될 때 전송 속도를 점진적으로 증가시키는 방식이다. 주요 특징은 다음과 같다:  
  
- **초기 윈도우 크기:** 초기 윈도우 크기는 일반적으로 1 또는 2 MSS(Maximum Segment Size)로 설정된다. 이는 초기 전송 속도를 낮추어 네트워크의 혼잡을 방지하기 위함이다.  
- **지수적 증가:** 매 RTT마다 윈도우 크기를 두 배로 증가시킨다. 예를 들어, 초기 윈도우 크기가 1 MSS인 경우, 첫 번째 RTT 후에는 2 MSS, 두 번째 RTT 후에는 4 MSS로 증가한다. 이로 인해 초기에는 빠르게 전송 속도가 증가하지만, 혼잡이 발생할 경우 AIMD로 전환된다.  
- **혼잡 회피:** Slow Start는 네트워크의 혼잡 상태를 감지하기 전에 전송 속도를 빠르게 증가시켜, 초기 전송 성능을 극대화한다. 그러나 혼잡이 발생하면 AIMD로 전환하여 전송 속도를 조절한다.  
- **혼잡 감지:** Slow Start는 혼잡 상태를 감지하기 위해 패킷 손실을 모니터링한다. 패킷 손실이 감지되면, 송신자는 윈도우 크기를 줄이고 Slow Start로 돌아간다.  
  
<br>
### TCP Tahoe
  
TCP Tahoe는 TCP의 혼잡 제어 알고리즘 중 하나로, Slow Start와 AIMD를 결합하여 혼잡을 관리한다. 주요 특징은 다음과 같다:  
  
- **혼잡 발생 시:** 패킷 손실이 감지되면, 윈도우 크기를 1 MSS로 줄이고 Slow Start로 돌아간다. 이는 혼잡 상태에서 전송 속도를 급격히 줄여 혼잡을 완화하기 위함이다.  
- **지수적 증가:** 초기에는 Slow Start로 윈도우 크기를 증가시키고, 혼잡이 발생하지 않으면 AIMD로 전환하여 점진적으로 증가시킨다. 이로 인해 네트워크의 혼잡을 효과적으로 관리할 수 있다.  
- **단순성:** TCP Tahoe는 구현이 간단하여 널리 사용되었지만, 혼잡 상황에서의 성능이 떨어지는 단점이 있다. 특히, 패킷 손실이 발생할 경우, 윈도우 크기를 1 MSS로 줄이는 방식은 성능 저하를 초래할 수 있다.  
- **혼잡 회복:** TCP Tahoe는 혼잡 회복을 위해 Slow Start로 돌아가며, 이를 통해 네트워크의 혼잡을 완화하고 안정적인 데이터 전송을 유지한다.  
  
<br>
### TCP Reno
  
TCP Reno는 TCP Tahoe의 개선된 버전으로, 혼잡 제어의 효율성을 높이기 위해 몇 가지 기능을 추가했다. 주요 특징은 다음과 같다:  
  
- **빠른 재전송:** 패킷 손실이 감지되면, 수신자가 중복 ACK를 보내는 경우, 송신자는 손실된 패킷을 즉시 재전송한다. 이를 통해 지연을 줄이고 성능을 향상시킨다. 예를 들어, 수신자가 3개의 중복 ACK를 수신하면, 송신자는 손실된 패킷을 즉시 재전송한다.  
- **빠른 회복:** 패킷 손실 후, 윈도우 크기를 절반으로 줄인 후 AIMD로 전환하여 전송 속도를 조절한다. 이로 인해 혼잡 상황에서의 성능이 개선된다. 예를 들어, 윈도우 크기가 6에서 혼잡이 감지되면 3으로 줄어들고, 이후 AIMD에 따라 점진적으로 증가한다.  
- **효율성 향상:** TCP Reno는 혼잡 상황에서의 성능을 개선하여, 데이터 전송의 안정성을 높인다. 빠른 재전송과 빠른 회복 기능을 통해 패킷 손실에 대한 반응 속도를 높이고, 전체적인 전송 성능을 향상시킨다.  
- **혼잡 감지:** TCP Reno는 혼잡 상태를 감지하기 위해 패킷 손실을 모니터링하며, 이를 기반으로 전송 속도를 조절한다. 혼잡이 발생하면 윈도우 크기를 줄이고, 혼잡이 해소되면 다시 증가시킨다  
  
<br>
### TCP의 문제점
  
- 1대1 통신만 가능하다.  
- handshake 과정을 통해 연결을 설정하고 해지하는 과정에서 추가적인 시간과 자원을 소모할 수 있다.  
특히 짧은 데이터를 빈번하게 전송하는 경우에는 handshake 과정이 오버헤드로 작용하여 성능 저하를 유발할 수 있다.  
- TCP는 데이터 전송의 신뢰성을 보장하기 위해 패킷의 전송 확인을 기다린다.   
이로 인해 데이터 전송 속도가 느려질 수 있고,   
특히 패킷 손실이 발생할 경우 재전송으로 인해 지연이 더욱 증가할 수 있다.  
  
<br><br><br>
## UDP (User Datagram Protocol) 란?
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/c4135e64-e11c-4c74-8831-4fb7ec01a8a1' alt=''>
  
사용자 데이터그램 프로토콜이라는 의미로   
비연결지향적이며 TCP보다 신뢰성이 떨어지지만 전송 속도가 일반적으로 빠른 프로토콜이다.  
  
- **비연결 지향적 Connectionless**: 연결 설정 과정이 없고, 데이터 전송에 필요한 부가적인 작업이 적기 때문에 데이터 전송 속도가 빠르다.  
- **순차 전송 보장 불가**: 정해진 경로 없이 패킷이 독립적으로 전송되어 데이터의 순차 전송을 보장하지 않으며, 패킷 손실이나 중복이 발생할 수 있다. 하지만 속도 면에서 이점을 가진다.  
- **흐름 및 혼잡을 제어 미지원**: 흐름 제어나 혼잡 제어 기능이 없어서 네트워크 상태에 따라 패킷 전송이 영향을 받을 수 있다.  
- **오류 감지**: UDP 헤더에는 체크섬(Checksum) 필드가 포함되어 있어, 수신자는 이를 통해 데이터그램의 오류를 감지할 수 있습니다. 하지만 오류가 감지되어도 재전송 기능은 제공하지 않는다.  
  
<br>
### data transfer
  
<img class='img-full' src='https://github.com/user-attachments/assets/178fe101-f6b8-4da7-a2d9-48d7562377cc' alt=''>
  
1. **데이터그램 생성**  
    - 애플리케이션에서 전송할 데이터는 UDP 헤더와 함께 UDP 데이터그램 형태로 캡슐화된다.  
    - UDP 헤더는 출발지 포트, 목적지 포트, 데이터 길이, 체크섬 등의 정보를 포함한다.  
2. **경로 선택**  
    - UDP 데이터그램은 IP 프로토콜에 의해 네트워크를 통해 전송된다.  
    - IP 프로토콜은 데이터그램의 목적지 IP 주소를 기반으로 최적의 전송 경로를 선택한다.  
3. **데이터 전송**  
    - UDP 데이터그램은 네트워크를 따라 목적지 호스트까지 전송된다.  
    - 데이터그램은 독립적으로 전송되며, TCP와 달리 데이터그램의 순서나 도착 여부는 보장되지 않는다.  
4. **데이터 수신**  
    - 목적지 호스트는 수신된 UDP 데이터그램에서 데이터를 추출한다.  
    - 체크섬을 통해 데이터 오류를 검출할 수 있지만, 재전송 기능은 제공하지 않는다.  
5. **응답 데이터그램 전송 (선택적)**  
    - 서버는 필요에 따라 응답 데이터그램을 생성하여 클라이언트에게 전송할 수 있다.  
    - 응답 데이터그램 또한 UDP 데이터그램 형태로 캡슐화되어 전송된다.  
6. **응답 데이터그램 수신 (선택적)**  
    - 클라이언트는 서버로부터 전송된 응답 데이터그램을 수신하여 필요한 경우 추가적인 처리를 수행할 수 있다.  
  
<br>
### 체크섬 (Checksum)
  
> UDP 패킷의 무결성을 검사하기 위해 사용되는 체크섬은   
비연결형 프로토콜의 특성상 발생할 수 있는 데이터그램의 손실이나 손상을 방지하고,   
데이터그램의 무결성을 보장한다.  
체크섬은 UDP 헤더와 페이로드를 결합하여 계산된 16비트 값으로 표현되며,   
수신자는 이 값을 통해 무결성을 검증한다.  
>
  
  
{:.notice--primary}
💡 **`체크섬 계산 과정`**<br><br>
1)  UDP 헤더와 데이터를 결합하여 하나의 데이터로 만든다.  
2)  결합된 데이터를 16비트 단위로 나눈다.  
3)  각 16비트 단위의 값을 모두 더한다.  
4)  계산된 값의 하위 16비트를 구한다.  
5)  하위 16비트 값의 1의 보수를 취하여 최종 체크섬을 얻는다.  
<br>
수신자는 도착한 UDP 패킷의 헤더와 페이로드를 동일한 방식으로 처리하여 체크섬을 계산하고,   
수신된 체크섬 값과 비교하여 무결성을 검증한다.   
만약 두 값이 일치하지 않으면 데이터그램이 손상되었을 가능성이 높아서  
수신자는 해당 패킷을 무시하거나 재요청을 수행할 수 있다.  
UDP 체크섬은 데이터 무결성을 확인하는 간단한 방법이지만, 신뢰성과 보안을 보장하지는 않는다.  
  
  
{:.notice--primary}
💡 **`UDP의 활용성`**<br><br>
◾ HTTP/3.0은 웹에서 데이터를 전송하기 위한 최신 프로토콜로, QUIC(Quick UDP Internet Connections)라는 전송 프로토콜 기반인데 QUIC는 UDP를 사용하여 데이터 전송을 수행하며, TCP의 지연 문제를 해결하기 위해 설계되었다.  
◾ DNS는 빠른 응답 속도가 매우 중요한 서비스로 연결 설정 과정이 없는 UDP가 효율적이다.  
◾ 이메일, 파일 송수신 같이 모든 데이터를 받아야하는 서비스의 경우 TCP 사용하는것이 적절하고  
실시간 애플리케이션(예: VoIP, 온라인 게임, 스트리밍 등)과 같이 빠른 전송 속도가 중요한 실시간 서비스에는 UDP를 사용하는 것이 적절하다.  
  
  
<br><br><br>
## IP (**Internet Protocol**) 란?
  
  
데이터 패킷을 출발지에서 목적지로 전송하기 위해 주소 지정 및 라우팅 기능을 제공하고,  
각 장치에 고유한 IP 주소를 할당하여 통신을 가능하게 하는 프로토콜이다.  
  
- **I**nternet Protocol 은 ****IP 주소를 사용해서 호스트나 네트워크 장비를 식별한다.  
인터넷에 접속한 컴퓨터와 라우터에 고유한 IP 주소를 할당하고,   
그 IP 주소를 사용해서 컴퓨터를 특정하거나 통신 상대방으로 지정한다.  
  
{:.notice--primary}
💡 **`IP 주소 체계`**<br><br>
IP 주소 체계는   
IPv4 와 IPv6 로 나뉘는데   
IP 프로토콜에서는 현재 IPv4의 주소 체계를 사용하고 있다.   
하지만 스마트폰의 등장 및 모든 사물이 인터넷으로 연결되는 사물 인터넷으로 인해   
IP 주소를 사용하는 기기가 폭발적으로 증가하면서   
IPv4보다 월등히 많은 수의 IP 주소를 할당 할 수 있는 IPV6가 사용되기 시작했고  
향후 모든 IP 주소는 IPv6로 대체될 것이라 보고 있다.  
  
  
<br>
### IPv4 (Internet Protocol version 4)
  
> Pv4의 IP 주소는 32비트로,   
이진수 32자리로 구성되어있는데  
이진수로 표기된 IP 주소는 사람이 알아보기 어렵기 때문에  
전체 32비트를 8비트씩 4그룹으로 나누어,  
각 그룹을 십진수로 변환하고,  
그룹의 경계에 `.` 을 넣은 형식으로 표기하고 있다.  
보통 IP 주소라 하면 IPv4를 의미한다.  
>
  
  
> IPv4로 할당할 수 있는 IP 주소의 개수는 2의 32승인 약 43억 개이다.  
>
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/b818fa7c-579a-40b5-b75d-7354c28d2719' alt=''>
  
<img class='img-full' src='https://github.com/user-attachments/assets/648e34c3-4258-4264-81bd-3d9e61510d06' alt=''>
  
<br>
### IP 주소
  
> IP 주소는 네트워크에서 호스트와 라우터의 각 인터페이스마다 할당되어 있는 식별 번호 이다.  
IP 주소는 호스트가 속한 네트워크 주소인 네트워크 부와 호스트의 주소인 호스트 부로 구성된다.  
네트워크 부 는 다른 네트워크와 구분하기 위함이고,  
호스트 부 는 특정 네트워크 내에서 다른 호스트와 구분하기 위함이다.  
>
  
  
> 그렇다면 IP 주소는 어떤 식으로 네트워크 부와 호스트 부가 구성되어있을까?  
IP 주소를 앞에서 8비트씩 나눈 그룹을 조합해서 네트워크 부와 호스트 부를 구성하는데  
이것을 다섯 개의 클래스(A,B,C,D,E)로 구분해서 각 클래스에 따라 네트워크 부와 호스트 부의 수를 조절한 것이다.  
>
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/6671c2fa-4b65-4295-979a-4a7d9a938a64' alt=''>
  
클래스 A 를 한 번 살펴보자면,  
클래스 A는 IP 주소 32비트 중 앞 8비트를 네트워크 부로,  
다음 24비트를 호스트 부로 나눈 것이다.  
네트워크 부의 첫 비트는 클래스 A 식별 비트인 "0"이 할당되기 때문에  
00000000 ~ 01111111의 번호가 네트워크 부로 사용된다.  
이를 십진수로 표기하면 클래스 A의 네트워크 부는 0 ~ 127의 번호가 할당된다.  
  
다음 24비트는 호스트 부로 사용되고,  
한 네트워크 안에서 할당할 수 있는 호스트 번호는 0.0.0 ~ 255.255.255까지이다.  
자세히 말하자면 IP 주소 관리기관이 IP 주소 신청자에게 클래스 A의 네트워크 부 1개를 할당하면,  
신청자는 약 1,677만 개의 호스트 부를 마음대로 정할 수 있게 되는 것이다.  
즉, 1개의 네트워크에 약 1,677만 개의 호스트를 연결할 수 있다.  
  
{:.notice--primary}
💡 **`이외에 클래스`**<br><br>
◾ 클래스 B:  
시작 비트: 10  
주소 범위: 128.0.0.0 ~ 191.255.255.255  
네트워크 비트: 16비트  
호스트 비트: 16비트  
중간 규모의 네트워크에 적합하며, 최대 65,534개의 호스트를 지원한다.  
◾ 클래스 C:  
시작 비트: 110  
주소 범위: 192.0.0.0 ~ 223.255.255.255  
네트워크 비트: 24비트  
호스트 비트: 8비트  
최대 254개의 호스트를 지원한다.  
◾ 클래스 D:  
시작 비트: 1110  
주소 범위: 224.0.0.0 ~ 239.255.255.255  
◾ 클래스 E:  
시작 비트: 1111  
주소 범위: 240.0.0.0 ~ 255.255.255.255  
  
  
<br>
### 네트워크 부와 호스트 부
  
<img class='img-full' src='https://github.com/user-attachments/assets/00e35b2e-468d-4a44-81bc-1e58665c996e' alt=''>
  
만약 위와 같이  
동일한 네트워크 부 203.179.33을 갖고 있는 호스트들은  
같은 네트워크 1에 속해 라우터를 통하지 않고 통신이 가능하지만  
다른 네트워크 2에 속한 호스트들은 네트워크 1과 다른 네트워크부를 갖고  
라우터를 통하지 않고서는 네트워크 1에 속한 호스트와 통신할 수 없다.  
  
네트워크 1과 네트워크 2가 통신을 위해서는  
네트워크 2에 속한 IP 주소가 192.168.24.4인 컴퓨터가  
네트워크 1에 속한 IP 주소 203.179.33.13인 컴퓨터로 IP 패킷을 전송하면 된다.  
그럼 라우터 2가 수신지 IP 주소의 네트워크 부 230.179.33을 보고 전송할 라우터를 찾아 IP 패킷을 전송하게 될 것이다.  
  
<br>
### 클래스 할당 방식의 단점
  
> 만약 클래스 A를 사용할 경우 한 개의 네트워크 당 약 1,677만 대의 호스트를 연결할 수 있고  
클래스 B를 사용할 경우 한 개의 네트워크 당 약 6만 5천대의 호스트를 연결할 수 있다.  
하지만 실제로 이렇게 많은 호스트를 하나의 네트워크에 연결하는 경우는 거의 없기 때문에  
전체 IP 주소의 75%를 차지하는 클래스 A와 클래스 B에서 많은 수의 IP 주소가 사용되지 않고 낭비된다.  
>
  
  
> 그래서 IP 주소를 효율적으로 활용하기 위해서  
클래스 A와 B 같은 대규모 네트워크를  
좀 더 작은 네트워크로 분할하는 `서브넷팅(Subnetting)` 을 하게되었고  
분할된 네트워크를 `서브넷(Subnet)` 이라고 했다.  
>
  
  
<br>
### **서브넷팅 (Subnetting)**
  
> 호스트 부의 비트를 서브넷 부로 변경하여 서브넷으로 만드는 것으로  
서브 넷팅을 하면 네트워크 부와 호스트 부로 구성되었던 클래스가 네트워크 부, 서브넷 부, 호스트 부로 변경된다.  
>
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/11e3e260-c476-464d-962e-91227544f98d' alt=''>
  
예를 들어, 클래스 A에서 네트워크 1개를 서브넷팅해서  
256 개의 서브넷을 만들었다고 가정해보자.  
호스트 부의 비트가 서브넷 부로 변경되면서  
1개의 네트워크에 약 1,677만 개의 호스트를 연결할 수 있던 수치가 줄어들어  
약 6만 5천 개의 호스트만 연결할 수 있게된다.  
즉, 서브넷팅을 통해 호스트 부가 서브넷 부로 변경되면서 네트워크 부가 확장됨에 따라  
1개의 네트워크에 필요한 만큼의 IP주소를 할당할 수 있게 된다.  
  
<br>
### 서브넷 마스크 (Subnet Mask)
  
> 여기서 중요한 것은  
IP 주소만으로는 서브넷팅을 했는지 안 했는지 구별이 불가능하다는 것이다.  
>
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/ed1ce44d-5463-4b03-a6f8-754ee9f01933' alt=''>
  
위와 같이 서브넷팅을 하기 전과 후의 IP주소는 차이가 없다.  
IP 주소를 서브넷팅하는 경우 IP 주소와 별도로  
어디까지가 네트워크 부이고 어디까지가 호스트 부인지 구별할 수 있는 식별자가 필요한데,  
이 식별자를 서브넷 마스크라고 한다.  
  
<img class='img-full' src='https://github.com/user-attachments/assets/50c04ecd-d7ed-4962-943f-54cbbb3b6268' alt=''>
  
서브넷 마스크는 IP 주소의 32비트에 대응한 32비트로 구성되어 있는데  
네트워크 부 비트에 대응하는 서브넷 마스크의 비트는 1로,  
호스트 부에 대응하는 서브넷 마스크의 비트는 0으로 바꾼다음  
프리픽스(prefix) 표기법을 사용하면 같은 IP 주소 이어도  
어디까지가 네트워크 부인지 식별할 수 있게 된다.  
  
이러한 방식으로 서브넷 마스크를 사용하면  
네트워크에 연결하고 싶은 호스트들의 규모에 맞게  
네트워크 부와 호스트 부의 길이를 1 비트 단위로 유연하게 변경하여 IP 주소를 할당할 수 있다.  
  
하지만 서브넷 마스크가 있더라도,  
IPv4 주소 공간이 제한적이기 때문에, 모든 장치에 고정적으로 고유한 IP 주소를 할당하는 것은 불가능에 가까웠기 때문에  
필요한 곳에 필요한 때에 필요한 수만큼 고유한 IP 주소를 할당하기 시작한 것인데  
어떻게 그것이 가능한 것일까?  
  
<br>
### 공인 IP 주소와 사설 IP 주소 그리고 NAT
  
**공인 IP 주소**  
  
> ISP에 의해 할당되고  
인터넷에서 라우터, 모뎀 또는 네트워크 장치에 할당되는  
고유한 IP 주소를 공인 IP 주소라고 한다.  
인터넷에 연결된 장치가 외부 네트워크와 통신할 수 있도록 허용하는 IP 주소인 것이다.  
>
  
  
{:.notice--primary}
💡 **`추가설명`**<br><br>
IP 주소는 임의로 우리가 부여하는 것이 아니라  
전 세계적으로 ICANN이라는 기관이 국가별로 사용할 IP 대역을 관리하고,  
우리나라는 한국인터넷진흥원(KISA)에서 국내 IP 주소들을 관리하고 있다.  
사용자가 ISP(Internet Service Provider의 약자로 KT, LG, SKT와 같이 인터넷을 제공하는 통신업체)를 통해  
인터넷 서비스를 이용하게 되면서  
IP 주소 관리기관이 ISP에 공인 IP 주소를 할당하고  
ISP가 사용자에게 공인 IP 주소를 부여하고 있다.  
  
  
**사설 IP 주소**  
  
> 로컬 네트워크 관리자에 의해 할당되고  
주로 공유기에 연결되어 있는 가정이나 회사의 각 네트워크 기기들에 할당되는  
어떤 네트워크 안에서만 내부적으로 사용되는 고유한 IP 주소를 사설 IP 주소라고 한다.  
>
  
  
{:.notice--primary}
💡 **`추가설명`**<br><br>
공인 IP 주소로 할당할 수 있는 IP 주소의 갯수는 한정적이기 때문에  
이를 해결할 수 있도록 사설 IP 주소를 사용한다.  
공유기를 사용한 인터넷 접속 환경일 경우 공유기까지는 공인 IP 할당을 하지만,  
공유기에 연결되어 있는 가정이나 회사의 각 네트워크 기기에는 사설 IP를 할당한다.  
공인 IP는 전 세계에서 유일하지만 사설 IP는 하나의 네트워크 안에서 유일하다.  
공인 IP는 외부, 내부 상관없이 해당 IP에 접속할 수 있으나,   
사설 IP는 인터넷 상에서 직접 접근할 수 없고 내부에서만 접근이 가능하다.  
어떤 네트워크 안에서 IP 주소를 사용하기 위해선 사설 네트워크를 만들어야하는데  
사설 네트워크를 만들 때는 사설 IP 주소로 사용 가능한 번호의 범위 내에서 IP 주소를 자유롭게 선택할 수 있다.  
인터넷에 연결되지 않으면 다른 네트워크의 사설 IP 주소와 겹치더라도  
사설 네트워크 안에서의 통신에는 전혀 문제가 없기 때문이다.  
  
  
<br>
### NAT (Network Address Translation)
  
> NAT는 주소 변환 기술로  
사설 IP 주소와 공인 IP 주소 간에 주소 변환을 해 사설 네트워크에서 인터넷으로 통신이 가능하게 한다.  
주로 라우터에 의해 구현되기 때문에 공유기에도 NAT 기술이 적용되어있다.  
>
  
  
<br>
### IP 주소의 할당
  
그렇다면 IP 주소는 어떻게 할당이 되는 것일까?  
사용자가 서버용으로 고정 IP를 신청하지 않는 이상 ISP는 인터넷 서비스 사용자에게 유동 IP를 할당하고  
공유기로 연결된 컴퓨터들은 인터넷 공유기의 IP 자동 설정 기능에 의해 네트워크 부에 IP 주소가 할당된다.  
  
{:.notice--primary}
💡 **`고정 IP와 유동 IP`**<br><br>
◾ 고정 IP  
<br>
    호스트에 IP 주소를 부여할 때 고정적으로 하나의 번호를 할당해 지속적으로 사용하는 방식을 고정 IP이다.  
<br>
<br>
    일반적으로 인터넷에서 서비스를 제공하는 서버는 고정 IP를 사용하여  
    클라이언트가 언제든 접속할 수 있도록 공인 IP 주소를 고정적으로 할당받아 사용한다.  
<br>
◾ 유동 IP  
<br>
    유동 IP는 인터넷에 접속할 때마다 별도로 IP 주소를 부여받는 방식이다.  
    인터넷에 접속하는 호스트에게 IP 주소를 할당하고,  
    접속이 끝나면 IP 주소를 다시 반납하여 다른 호스트에게 할당하여  
    네트워크에 연결되어 있는 호스트보다 적은 수의 IP 주소로 운영이 가능하다.  
<br>
<br>
    서버 외에 필요할 때 인터넷에 접속하는 클라이언트 같은 호스트는 유동 IP를 사용하는 것이 효율적이다.  
  
  
<br>
### 통신과정
  
<img class='img-full' src='https://github.com/user-attachments/assets/5fe50440-ad4f-48d2-9e07-2a89e2cfb0a3' alt=''>
  
1. 클라이언트 1은 서버에게 서비스를 요청하는 내용의 IP 패킷을 만들어 전송한다.  
IP 패킷의 IP 헤더에는 송신지 IP 주소 192.168.24.2,  
수신지 IP 주소 203.179.33.13이라는 정보가 담겨 있다.  
2. 클라이언트 1이 전송한 IP 패킷이 NAT 지원 라우터에 도착하면  
다시 말해 NAT 라우터가 IP 헤더의 송신지 주소를  
사설 IP 주소인 192.168.24.2에서 공인 IP 주소인 202.244.73.3으로 변경한 IP 패킷을 인터넷으로 전송한다.  
일반적인이라면 203.179.33.13은 고정 IP에 해당하고 202.244.73.3은 유동 IP에 해당한다.  
송신지 IP 주소를 변환할 때 라우터에는 변환 전후의 주소를 기록한 NAT 테이블이 만든다.  
3. 서버에 도착한 IP 패킷에 응답하여  
서버가 클라이언트 1로 서비스를 제공하는 IP 패킷을 보낼 때는  
반대로 공인 IP 주소가 사설 IP 주소로 변환되는 과정을 거친다.  
서버는 자신이 아는 수신지 주소인 공인 IP 주소 202.244.73.3로 IP 패킷을 전송한다.  
이 패킷이 라우터에 도착하면 라우터는 NAT 테이블을 이용해  
수신지 공인 IP 주소를 클라이언트의 원래 주소인 사설 IP 주소 192.168.24.2로 변환하고 IP 패킷을 전송한다.  
  
중요한 것은  
NAT 라우터가 하나의 공인 IP 주소를 갖는 하나의 호스트 역할을 해서  
사설 네크워크의 호스트들이 해당 공인 IP 주소를 공유하면서 인터넷 통신이 가능하다는 점이다.  
즉, 서브넷 마스크 방식의 주소 할당, 유동 IP 할당, NAT을 사용한 주소 변환을 통해서  
IPv4 주소 체계만으로는 많은 주소들을 모두 감당하지 못하는 단점을 해결할 수 있었다는 것이다.  
  
<br>
### IPv6 (Internet Protocol version 6)
  
> IPv6는 128 비트로  
전체 128비트를 16비트씩 8그룹으로 나누어  
각 그룹을 16진수로 변환하고,  
그룹의 경계를 `:` 으로 구분하는 형식으로 표기한다.  
IPv6로 할당할 수 있는 IP 주소의 개수는 2의 128승, 약 340간(약 340조 X 1조 X 1조)개이다.  
>
  
  
> 즉, IPv6는 IPv4로 할당할 수 있는 IP 주소의 개수 43억을 4번 곱한 숫자로  
IPv6에서는 IP 주소 공간 확장뿐만 아니라  
IPv4의 단점을 보완하여 클래스와 사설 IP 주소 및 NAT을 사용하지 않고  
모든 호스트에 자동으로 공인 IP를 할당하여 보다 간단하게 주소를 설정할 수 있게 되었다.  
>
  
  
<img class='img-full' src='https://github.com/user-attachments/assets/0f264e63-acfe-44dd-ba8b-00696cdcaea7' alt=''>
  
{:.notice--primary}
💡 **`IPv6 도입`**<br><br>
서브넷 마스크 방식의 주소 할당, 유동 IP 할당, NAT을 사용한 주소 변환을 통해서  
IPv4의 주소 고갈 문제를 해결해왔어도  
스마트폰 등 모바일 컴퓨터의 확산과  
모든 사물을 인터넷으로 연결하는 사물인터넷의 등장으로  
인터넷에서 필요한 IP 주소가 기하급수적으로 늘어나면서  
IPv4의 주소 고갈 문제를 근본적으로 해결할 새로운 주소 체계인 IPv6를 도입되었다.  
<br>
하지만 IPv4를 기반으로 한 네트워크와 IPv6를 기반으로 한 네트워크는 서로 호환되지 않아 IP 패킷을 전송할 수 없기에  
인터넷 상의 모든 네트워크를 IPv4에서 IPv6로 전환하는 작업을 해야 한다.  
<br>
그래서 아직까지 IPv4가 IPv6로 전환되기까지는 시간이 더 걸릴 것으로 예상하고 있고  
새로운 IPv6 네트워크를 확대해나가면서도 기존 IPv4 네트워크와 IP 패킷 전송이 가능하도록,  
두 주소 체계가 공존할 수 있는 전환 기술(듀얼 스택 기술, 터널링 기술, 헤더 변환 기술)을 사용하여 점진적인 전환을 꾀하고 있다.  
  
  
<br><br><br>
**reference**
  
  
- <a href='https://www.youtube.com/watch?v=BEK354TRgZ8&list=PLFTA8K42D3APWE3Q2TBrn4p0Y3Cl0JcRd&index=13' target='_blank'>https://www.youtube.com/watch?v=BEK354TRgZ8&list=PLFTA8K42D3APWE3Q2TBrn4p0Y3Cl0JcRd&index=13</a>
  
- <a href='https://www.youtube.com/watch?v=ikDVGYp5dhg' target='_blank'>https://www.youtube.com/watch?v=ikDVGYp5dhg</a>
  
- <a href='https://www.nossi.dev/405c51e4-778c-45a5-9920-c239f2468417' target='_blank'>https://www.nossi.dev/405c51e4-778c-45a5-9920-c239f2468417</a>
  
- <a href='https://better-together.tistory.com/124#google_vignette' target='_blank'>https://better-together.tistory.com/124#google_vignette</a>
